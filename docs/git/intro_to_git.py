"""Git и организация программных проектов."""

# <p> Системы контроля версий представляют собой программные средства, которые регистрируют все изменения в исходном коде и позволяют легко восстановить старые версии. </p>
# <p>Система контроля версий управляет файлами при внесении в них изменений.</p>
# <p>Git, Mercurial и Subversion — популярные приложения контроля версий, хотя система Git остается самой популярной. </p>

# ### Коммиты и репозитории
# <p> Git позволяет сохранить состояние файлов проекта при внесении в них изменений. Такие сохранения называются снимками (snapshots) или коммитами (commits).</p>
# <p>Системы контроля версий также позволяют команде разработчиков синхронизировать свою работу при внесении изменений в исходный код проекта. Когда каждый программист закрепляет свои изменения, другие могут извлекать эти обновления на своих компьютерах. Система контроля версий следит за тем, какие изменения были внесены, кто и когда их сделал, а также сохраняет комментарии разработчиков, описывающие эти изменения.</p>
# <p>Система контроля версий управляет исходным кодом проекта, который хранится в специальной папке — репозитории (repo). Как правило, для каждого проекта, над которым вы работаете, следует создать отдельный репозиторий Git. Предположим, вы работаете в основном самостоятельно над своей частью программы и вам не нужны расширенные возможности Git (такие как ветвление и слияние), упрощающие работу с остальными участниками. Но даже если вы работаете в одиночку, самый маленький проект все равно выиграет от применения системы контроля версий.</p>

# ### Создание новых проектов Python с использованием Cookiecutter
# <p>В терминологии Git папка, содержащая весь исходный код, документацию, тесты и другие файлы, относящиеся к проекту, называется рабочим каталогом или рабочим деревом, а в более общей терминологии — папкой проекта. Файлы в рабочем каталоге в совокупности называются рабочей копией.</p>
#
# <p>Прежде чем создавать репозиторий Git, следует создать файлы для проекта Python.</p>
#
# <p>Для проектов Python действуют определенные соглашения по поводу имен папок и иерархий. Более простая программа может содержать один файл .py. Но когда проекты усложнятся, в них будут включаться дополнительные файлы .py, файлы данных, документация, модульные тесты и т. д. Как правило, корневая папка проекта содержит папку src для файлов с исходным кодом .py, папку tests для модульных тестов и папку docs для документации (например, сгенерированной системой документирования Sphinx). Другие файлы содержат информацию о проекте и конфигурации системы: README.md для общей информации, .coveragerc для конфигурации покрытия кода, LICENSE.txt для текста программной лицензии проекта и т. д.</p>
#
# <p>Чтобы ускорить выполнение рутинных операций, можно использовать модуль Python cookiecutter для автоматического создания этих файлов и папок. Полная документация по модулю и программе командной строки Cookiecutter доступна на https://cookiecutter.readthedocs.io/.</p>
#
# <p>Если вы не знаете, для чего нужны те или иные файлы, не огорчайтесь. Хотя полное описание назначения каждого файла выходит за рамки книги, на странице https://github.com/asweigart/cookiecutter-basicpythonproject присутствуют ссылки и нужная информация. Итак, базовые файлы созданы, и мы переходим к отслеживанию изменений в них в системе Git.</p>

# ![image.png](attachment:image.png)

# ### Установка Git
#
# <p>Git уже установлена на моем компьютере.</p>
#
# <p>Чтобы узнать это, введите команду `git --version` в командной строке.</p>
#
# <p>У меня выводится: `git version 2.45.0.windows.1`</p>

# ## Работа с Git
#
# Работа с репозиторием Git состоит из нескольких этапов:
#
# 1. Создание репозитория:
#    - Командой `git init` для нового проекта
#    - Или `git clone` для копирования существующего
#
# 2. Добавление файлов для отслеживания:
#    - Используется команда `git add <имя_файла>`
#    - Можно добавить все файлы: `git add .`
#
# 3. Сохранение изменений:
#    - Команда `git commit -am "<сообщение коммита>"`
#    - В сообщении описывается содержание изменений
#

#
# ### Справка по командам
#
# Для получения справки по любой команде используйте:
#
# Чтобы получить справку по командам в GitHub, можно использовать команду «git help». 24 Она предоставляет обзор доступных команд и способов их использования.
#
# Ещё несколько способов открыть страницу руководства по конкретной команде Git:
#
# git help <команда>. 45 Например, чтобы получить справку по команде commit, нужно выполнить: git help commit.
# git <команда> --help. Например, так можно открыть руководство по команде git config: git config --help.
# man git-<команда>. 45 Например, чтобы просмотреть страницу руководства по конкретной команде Git, нужно ввести: man git-config.
#
# Если нужна персональная помощь, можно попробовать поискать её на каналах #git и #github IRC сервера Libera Chat, который доступен по адресу libera.chat.

# ## Как Git отслеживает статус файлов
#
# ### Основные состояния файлов
#
# 1. **Неотслеживаемые (Untracked)**:
#    - Файлы, которые Git не видит
#    - Для Git эти файлы не существуют
#    - Нужно добавить через `git add`
#
# 2. **Отслеживаемые (Tracked)** файлы имеют три состояния:
#    - **Сохраненные (Committed)**: идентичны последнему коммиту
#    - **Измененные (Modified)**: отличаются от последнего коммита
#    - **Индексированные (Staged)**: помечены для следующего коммита
#
# ### Переходы между состояниями
#
# 1. Неотслеживаемый → Индексированный:
#    - Используется `git add <файл>`
#
# 2. Сохраненный → Измененный:
#    - Происходит автоматически при изменении файла
#    - Не требует команд Git
#
# 3. Измененный → Индексированный:
#    - Используется `git add <файл>`
#
# 4. Индексированный → Сохраненный:
#    - Используется `git commit`
#
# ### Проверка статуса
# Команда `git status`
#
# ### Важные заметки:
# - Команду `git status` рекомендуется использовать часто
# - Git подсказывает команды для изменения состояния файлов
# - Файл может находиться только в одном состоянии

#
#

# ## Для чего нужно индексирование?
#
# ### Сложности индексирования
#
# 1. **Особые случаи**:
#    - Файл может быть одновременно в измененном и индексированном состоянии
#    - Разные части файла могут иметь разные состояния
#    - Технически индексируются не файлы, а описания изменений
#
# 2. **Проблемы для новичков**:
#    - Вызывает недоумение
#    - Создает путаницу
#    - Усложняет понимание Git
#    - Часто описывается неточно в документации
#
# ### Как упростить работу
#
# 1. **Использовать команду `git commit -am`**:
#    - Объединяет индексирование и коммит
#    - Файлы переходят сразу из измененного в чистое состояние
#    - Упрощает процесс сохранения
#
# 2. **Рекомендации по работе**:
#    - Сразу сохранять файлы после добавления
#    - Немедленно коммитить после переименования
#    - Не откладывать коммиты после удаления файлов
#
# 3. **Альтернативные решения**:
#    - Использовать графические интерфейсы Git
#    - Избегать сложных случаев
#    - Придерживаться простых сценариев использования

# ## Создание репозитория Git на компьютере
#
# ### Особенности Git как распределенной системы
#
# 1. **Локальное хранение**:
#    - Все коммиты хранятся на компьютере
#    - Метаданные в папке `.git`
#    - Не требует подключения к интернету
#    - Быстрая работа даже офлайн
#
# ### Создание нового репозитория

# 1. **Создание папки и инициализация**:
#
# # Для Windows:
# md wizcoin
#
# # Для macOS/Linux:
# # mkdir wizcoin
#
# # Для всех систем:
# # cd wizcoin
# git init

# 2. **Что происходит при инициализации (git init)**:
#    - В папке создается скрытая подпапка `.git`
#    - Эта папка превращается в Git-репозиторий
#    - Все существующие файлы становятся неотслеживаемыми (untracked)
#    - В `.git` хранятся все данные о версиях (не нужно редактировать вручную!)
#
# ### Типы репозиториев
#
# 1. **Локальный репозиторий**:
#    - На вашем компьютере
#    - Для личной работы
#
# 2. **Удаленный репозиторий**:
#    - На другом компьютере
#    - Для совместной работы
#
# ### Мониторинг статуса (watch)
#
# watch - это утилита, которая: Что делает:
# Автоматически повторяет команду
# Показывает результат каждые 2 секунды
# Обновляет экран автоматически
# Как "живой" мониторинг
#
# Зачем это нужно:
# Не надо постоянно вводить git status
# Видишь изменения сразу
# Удобно следить за репозиторием
# Как "радар" для Git
#
#
# 1. **Установка watch**:
#    - Windows: скачать с https://inventwithpython.com/watch.exe
#    - macOS: через MacPorts
#    - Linux: предустановлен
#
# 2. **Использование**:
# watch "git status" # обновление каждые 2 секунды
# watch "git log --oneline" # мониторинг коммитов

#

# ### Добавление файлов для отслеживания
#
# 1. **Проверка статуса файлов**:
#    - Команда `git status` показывает состояние файлов
#    - Неотслеживаемые файлы помечены как "Untracked files"
#    - Git не может сохранять неотслеживаемые файлы
#    - Нужно сначала добавить их для отслеживания
#
# 2. **Процесс добавления файлов**:
#    - Сначала `git add` (индексирование файлов)
#    - Затем `git commit` (создание коммита)
#    - После этого Git начинает отслеживать файлы
#
# 3. **Способы использования git add**:
#    - `git add file.txt` - добавить один файл
#    - `git add *.py` - добавить все Python файлы
#    - `git add .` - добавить все файлы в текущей папке
#
# 4. **Создание коммита**:
#    - `git commit -m "Сообщение коммита"` - сохраняет индексированные файлы
#    - В сообщении описываем, какие изменения внесли
#    - После коммита файлы становятся отслеживаемыми
#
# 5. **Важные замечания**:
#    - Файлы из `.gitignore` автоматически пропускаются
#    - Можно добавлять файлы группами
#    - Каждый коммит требует сообщения
#    - После успешного коммита рабочая директория "чистая"

#

# ### Игнорирование файлов в Git (.gitignore)
#
# 1. **Зачем игнорировать файлы**:
#    - Временные файлы проекта
#    - Компилированные файлы (`.pyc`, `.pyo`, `.pyd`)
#    - Папки инструментов разработки (`.tox`, `htmlcov`)
#    - Сгенерированные файлы (можно создать заново)
#    - Файлы с конфиденциальными данными (пароли, токены)
#
# 2. **Как использовать .gitignore**:
#    - Создать файл `.gitignore` в корне проекта
#    - Записать в него шаблоны игнорируемых файлов
#    - Git автоматически пропустит эти файлы при `git add` и `git commit`
#    - Файлы не будут показываться в `git status`
#
# 3. **Синтаксис .gitignore**:
#    ```
#    # Комментарий
#    __pycache__/          # Игнорировать папку
#    *.py[cod]            # Игнорировать файлы по маске
#    *$py.class           # Конкретный шаблон
#    ```
#
# 4. **Важные моменты**:
#    - Сам файл `.gitignore` нужно добавить в репозиторий
#    - Используйте `*` для шаблонов файлов
#    - Используйте `#` для комментариев
#    - Проверить игнорируемые файлы: `git ls-files --other --ignored --exclude-standard`
#
# 5. **Документация**: https://git-scm.com/docs/gitignore

# ### Сохранение изменений в Git
#
# 1. **Основные команды**:
#    - `git commit -am "сообщение"` - сохранить все измененные файлы
#    - `git commit -m "сообщение" file1.py file2.py` - сохранить конкретные файлы
#    - `git commit --amend -m "новое_сообщение"` - исправить последний коммит
#
# 2. **Правила хороших сообщений**:
#    - Подробно описывать изменения
#    - Избегать общих фраз ("обновил код", "фикс")
#    - Помогать себе в будущем понять изменения
#    - Пример: "Fixed the currency conversion bug"
#
# 3. **Важные моменты**:
#    - Нельзя сохранять пустые папки
#    - Git автоматически включает папки с файлами
#    - После коммита файлы готовы к новым изменениям
#    - Vim открывается если забыть `-m "сообщение"` (выход: Esc + qa!)
#
# 4. **Хорошая практика**:
#    - Делать частые коммиты
#    - Писать понятные сообщения
#    - Группировать связанные изменения
#    - Изучать примеры больших проектов (например, Django)

#

# ### Просмотр изменений перед коммитом (git diff)
#
# 1. **Основное использование**:
#    ```bash
#    git diff              # показать все несохраненные изменения
#    git diff file.py      # изменения в конкретном файле
#    ```
#
# 2. **Как читать вывод git diff**:
#    - `-` красным: удаленные строки
#    - `+` зеленым: добавленные строки
#    - `@@ -13,7 +13,14 @@`: координаты изменений
#    - Показывает контекст вокруг изменений
#
# 3. **Процесс работы**:
#    1. Внести изменения в файл
#    2. `git diff` - проверить изменения
#    3. Исправить ошибки если найдены
#    4. `git add` - добавить в индекс
#    5. `git commit` - сохранить изменения
#
# 4. **Преимущества использования**:
#    - Можно поймать опечатки
#    - Проверить все изменения
#    - Убедиться в правильности кода
#    - Не сохранять лишнее
#
# 5. **Пример рабочего процесса**:
#    ```bash
#    git diff                                    # проверить изменения
#    git add README.md                          # добавить файл
#    git commit -m "Added example code to README.md"  # сохранить
#    ```

# ### Просмотр изменений через git difftool
#
# 1. **Установка инструментов сравнения**:
#    - **Windows**: WinMerge (https://winmerge.org)
#    - **Linux**:
#      ```bash
#      sudo apt-get install meld
#      # или
#      sudo apt-get install kompare
#      ```
#    - **macOS**:
#      ```bash
#      # Установка Homebrew
#      /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"
#      # Установка tkdiff
#      brew install tkdiff
#      ```
#
# 2. **Настройка Git**:
#    ```bash
#    # Выбор инструмента
#    git config diff.tool winmerge   # или meld, tkdiff, kompare
#
#    # Отключение запроса подтверждения
#    git config --global difftool.prompt false
#    ```
#
# 3. **Использование**:
#    ```bash
#    git difftool file.txt   # открыть изменения в графическом интерфейсе
#    ```
#
# 4. **Преимущества**:
#    - Удобный визуальный интерфейс
#    - Легче сравнивать изменения
#    - Больше возможностей для анализа
#    - Интеграция с Git-клиентами

#

# ### Частота сохранения изменений в Git
#
# 1. **Когда делать коммиты**:
#    - После завершения функционала
#    - После исправления бага
#    - После написания класса
#    - Когда код работоспособен
#
# 2. **Чего избегать**:
#    - Коммитов с синтаксическими ошибками
#    - Неработающего кода
#    - Слишком редких коммитов
#    - Слишком частых коммитов
#
# 3. **Правила хорошего тона**:
#    - Запускать тесты перед коммитом
#    - Проверять работоспособность
#    - Писать понятные сообщения
#    - Группировать связанные изменения
#
# 4. **Баланс в размере коммитов**:
#    - Может быть несколько строк
#    - Может быть несколько сотен строк
#    - Главное - логическая завершенность
#    - Возможность отката к рабочей версии
#
# 5. **Важно помнить**:
#    - Лучше коммитить чаще, чем реже
#    - Каждый коммит должен быть осмысленным
#    - Упоминать о непроходящих тестах
#    - Сохранять возможность отката

# ### Удаление файлов в Git
#
# 1. **Правильное удаление файлов**:
#    ```bash
#    git rm file.txt              # удалить файл
#    git commit -m "Удалил file.txt"  # сохранить удаление
#    ```
#
# 2. **Чего НЕ делать**:
#    - Не использовать `del` (Windows)
#    - Не использовать `rm` (macOS/Linux)
#    - Не удалять файлы вручную
#    - Не забывать про коммит после удаления
#
# 3. **Если удалили файл вручную**:
#    ```bash
#    git restore file.txt    # восстановить файл
#    # или
#    git rm file.txt        # подтвердить удаление
#    ```
#
# 4. **Важные моменты**:
#    - Файл остается в истории Git
#    - Можно восстановить позже
#    - Нужно коммитить удаление
#    - Работает только с "чистыми" файлами
#
# 5. **Процесс удаления**:
#    1. `git rm file.txt`
#    2. Git индексирует удаление
#    3. Нужен коммит для завершения
#    4. Файл удаляется из рабочей копии

# ### Переименование и перемещение файлов в Git
#
# 1. **Правильное переименование**:
#    ```bash
#    git mv старый.txt новый.txt
#    git commit -m "Переименовал файл"
#    ```
#
# 2. **Перемещение файлов**:
#    ```bash
#    mkdir новая_папка
#    git mv файл.txt новая_папка/файл.txt
#    git commit -m "Переместил файл"
#    ```
#
# 3. **Комбинированные операции**:
#    ```bash
#    git mv старый_путь/старый.txt новый_путь/новый.txt
#    git commit -m "Переместил и переименовал"
#    ```
#
# 4. **Чего НЕ делать**:
#    - Не переименовывать через проводник
#    - Не перемещать файлы вручную
#    - Не забывать про коммит
#    - Не игнорировать git mv
#
# 5. **Важные моменты**:
#    - История файла сохраняется
#    - Git отслеживает перемещения
#    - Нужен коммит после операций
#    - Можно комбинировать действия

# ### Просмотр журнала коммитов (git log)
#
# 1. **Основные команды**:
#    ```bash
#    git log                  # полный журнал
#    git log --oneline       # сокращенный формат
#    git log -n 3            # последние 3 коммита
#    git show хеш:файл.txt   # содержимое файла в коммите
#    ```
#
# 2. **Структура коммита**:
#    - Хеш (40 символов)
#    - Автор
#    - Дата
#    - Сообщение коммита
#
# 3. **Удобные опции**:
#    - `--oneline`: краткий формат
#    - `-n число`: ограничение количества
#    - `q`: выход из просмотра
#    - `↑` и `↓`: навигация по журналу
#
# 4. **Хеши коммитов**:
#    - 40 символов (полный хеш)
#    - Первые 7 символов (короткий)
#    - Уникальные идентификаторы
#    - Используются для возврата к версиям
#
# 5. **Важно знать**:
#    - Журнал может быть длинным
#    - Хеши уникальны
#    - Можно использовать GUI клиенты
#    - История сохраняется полностью

# ### Просмотр журнала коммитов (git log)
#
# 1. **Базовый просмотр**:
#    ```bash
#    git log                  # полный журнал со всеми деталями
#    ```
#    Показывает:
#    - Полный хеш коммита
#    - Автора и email
#    - Дату и время
#    - Сообщение коммита
#
# 2. **Сокращенный просмотр**:
#    ```bash
#    git log --oneline        # краткий формат
#    git log --oneline -n 3   # только последние 3 коммита
#    ```
#
# 3. **Просмотр содержимого**:
#    ```bash
#    git show хеш:файл.txt    # содержимое файла в конкретном коммите
#    ```
#
# 4. **Навигация в журнале**:
#    - `↑` и `↓`: прокрутка
#    - `q`: выход из просмотра
#    - `Space`: следующая страница
#
# 5. **Хеши коммитов**:
#    - Полный: 40 символов (962a8baa29e452c74d40075d92b00897b02668fb)
#    - Короткий: 7 символов (962a8ba)
#    - Используются для идентификации коммитов
#    - Нужны для возврата к предыдущим версиям

# ### Отмена несохраненных изменений
#
# 1. **Основные команды**:
#    ```bash
#    git restore file.txt     # отменить изменения в одном файле
#    git checkout .          # отменить все изменения во всех файлах
#    ```
#
# 2. **Важные моменты**:
#    - Работает только для несохраненных изменений
#    - Нельзя отменить restore
#    - Возвращает к последнему коммиту
#    - Будьте осторожны - изменения пропадут!
#
# 3. **Процесс отмены**:
#    1. Проверить статус (`git status`)
#    2. Убедиться, что файлы не в индексе
#    3. Использовать `git restore`
#    4. Проверить результат
#
# 4. **Когда использовать**:
#    - Случайные изменения
#    - Неудачный эксперимент
#    - Возврат к чистой версии
#    - До индексации файлов
#
# 5. **⚠️ Предупреждения**:
#    - Отмена необратима
#    - Проверяйте статус перед отменой
#    - Сохраняйте важные изменения
#    - Используйте с осторожностью

# ### Деиндексирование файлов (unstage)
#
# 1. **Основная команда**:
#    ```bash
#    git restore --staged file.txt    # убрать файл из индекса
#    ```
#
# 2. **Что происходит**:
#    - Файл остается измененным
#    - Убирается из индекса
#    - Не попадет в следующий коммит
#    - Статус меняется на "modified"
#
# 3. **Когда использовать**:
#    - После случайного `git add`
#    - При изменении планов
#    - Перед новым коммитом
#    - Для перегруппировки изменений
#
# 4. **Процесс**:
#    1. Файл изменен
#    2. `git add` (в индексе)
#    3. `git restore --staged` (из индекса)
#    4. Файл все еще изменен
#
# 5. **Важно помнить**:
#    - Изменения в файле сохраняются
#    - Можно снова добавить в индекс
#    - Не влияет на сам файл
#    - Только убирает из очереди на коммит

# ### Отмена последних коммитов (git revert)
#
# 1. **Основная команда**:
#    ```bash
#    git revert -n HEAD~3..HEAD    # отменить последние 3 коммита
#    git add .                     # добавить изменения
#    git commit -m "Отмена изменений"  # сохранить отмену
#    ```
#
# 2. **Как это работает**:
#    - Создает новый коммит
#    - Отменяет указанные изменения
#    - Сохраняет историю
#    - Можно отменить отмену
#
# 3. **Пример истории**:
#    ```bash
#    faec20e (HEAD) Starting over from the plot twist
#    de24642 Changed the setting to outer space
#    2be4163 Added a whacky sidekick
#    97c655e Renamed the detective to 'Snuggles'
#    8aa5222 Added an exciting plot twist
#    ```
#
# 4. **Важные моменты**:
#    - Коммиты не удаляются
#    - История сохраняется
#    - Можно вернуться к любой версии
#    - Безопасная операция
#
# 5. **Процесс отмены**:
#    1. Выбрать количество коммитов
#    2. Выполнить `git revert`
#    3. Добавить изменения
#    4. Создать коммит отмены

# ### Возврат к определенной версии файла
#
# 1. **Просмотр старой версии**:
#    ```bash
#    git show хеш:файл.py    # посмотреть содержимое
#    ```
#
# 2. **Восстановление файла**:
#    ```bash
#    git checkout хеш -- файл.py    # вернуть к версии
#    git add файл.py               # добавить в индекс
#    git commit -m "Откат к версии хеш"  # сохранить
#    ```
#
# 3. **Пример истории**:
#    ```bash
#    d41e595 Rolled back eggs.py to 009b7c0
#    895d220 Adding email support to cheese()
#    df617da Renaming bacon() to cheese()
#    ef1e4bb Refactoring bacon()
#    009b7c0 Adding better documentation to spam()
#    ```
#
# 4. **Важные моменты**:
#    - Откат только одного файла
#    - Остальные файлы не меняются
#    - Создается новый коммит
#    - История сохраняется
#
# 5. **Процесс отката**:
#    1. Найти нужный коммит
#    2. Проверить содержимое (`git show`)
#    3. Восстановить файл (`git checkout`)
#    4. Создать коммит с откатом

#

# ### Работа с конфиденциальными данными в Git
#
# 1. **Предотвращение утечек**:
#    ```bash
#    # .gitignore
#    secrets.txt
#    confidential.py
#    *.key
#    *.password
#    ```
#
# 2. **Если данные уже попали в репозиторий**:
#    - Использовать `git filter-branch`
#    - Или BFG Repo-Cleaner (рекомендуется)
#    - Ссылка: https://help.github.com/en/articles/removing-sensitive-data-from-a-repository
#
# 3. **Правильный подход**:
#    - Хранить секреты отдельно
#    - Добавлять файлы в `.gitignore`
#    - Использовать переменные окружения
#    - Читать данные из внешних файлов
#
# 4. **Что НЕ делать**:
#    - Не коммитить пароли
#    - Не хранить ключи API
#    - Не включать токены
#    - Не добавлять личные данные
#
# 5. **Безопасные практики**:
#    - Создавать `secrets.txt.example`
#    - Использовать конфиг-файлы
#    - Документировать процесс
#    - Регулярно проверять историю

# ### GitHub и публикация репозитория
#
# 1. **Что такое GitHub**:
#    - Веб-сервис для Git репозиториев
#    - Бесплатный хостинг кода
#    - Платформа для совместной работы
#    - Резервное копирование
#
# 2. **Создание репозитория на GitHub**:
#    ```bash
#    1. Зайти на github.com
#    2. Нажать New Repository
#    3. Указать имя (например, wizcoin)
#    4. Добавить описание
#    5. Выбрать Public/Private
#    6. Create repository
#    ```
#
# 3. **Структура ссылок**:
#    ```
#    https://github.com/username/repository
#    # Пример:
#    https://github.com/asweigart/wizcoin
#    ```
#
# 4. **Важные моменты**:
#    - Git ≠ GitHub
#    - Git = система контроля версий
#    - GitHub = веб-сервис для Git
#    - Можно работать оффлайн
#
# 5. **Преимущества GitHub**:
#    - Совместная работа
#    - Резервное копирование
#    - Доступ из любого места
#    - Публичное портфолио

# ### Работа с GitHub репозиторием
#
# 1. **Отправка локального репозитория**:
#    ```bash
#    # Привязка удаленного репозитория
#    git remote add origin https://github.com/username/repo.git
#
#    # Первая отправка
#    git push -u origin master
#
#    # Последующие отправки
#    git push
#    ```
#
# 2. **Клонирование с GitHub**:
#    ```bash
#    git clone https://github.com/username/repo.git
#    ```
#
# 3. **Важные моменты**:
#    - Отправлять изменения регулярно
#    - Проверять статус синхронизации
#    - Использовать HTTPS или SSH
#    - Хранить учетные данные безопасно
#
# 4. **Процесс работы**:
#    1. Создать репозиторий на GitHub
#    2. Привязать локальный репо
#    3. Отправить изменения
#    4. Регулярно синхронизировать
#
# 5. **Аварийное восстановление**:
#    - Сохранить рабочие файлы
#    - Удалить проблемный локальный репо
#    - Заново клонировать с GitHub
#    - Вернуть изменения

# Оновные моменты:
# Git - это система контроля версий, которая позволяет:
# Отслеживать изменения в коде
# Возвращаться к предыдущим версиям
# Работать над проектом в команде
#
# Основные состояния файлов в Git:
# Неотслеживаемые (untracked)
# Отслеживаемые (tracked):
# Сохраненные (committed)
# Измененные (modified)
# Индексированные (staged)
#

# # Основные команды Git:
# git init # создать новый репозиторий
# git add # добавить файлы для отслеживания
# git commit # сохранить изменения
# git status # проверить статус файлов
# git log # просмотреть историю коммитов
# git push # отправить изменения на GitHub

# Для организации Python проектов рекомендуется:
# Использовать cookiecutter для создания структуры проекта
# Создавать отдельный репозиторий для каждого проекта
# Регулярно коммитить изменения
# Использовать .gitignore для исключения ненужных файлов
# GitHub позволяет:
# Хранить копию репозитория онлайн
# Делиться кодом с другими разработчиками
# Создавать резервные копии
