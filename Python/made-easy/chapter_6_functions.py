"""Функции."""

# 6.1 . Определение функций
# Первый вопрос, на который нам нужно ответить: что такое функция?
# В Python функция - это группа связанных операторов, выполняющих определен-
# ную задачу.
# С помощью функций можно разбить программу на более мелкие части. По мере
# того как наша программа становится все больше и больше, функции становятся
# все
# более и более необходимы для поддержания организованности и управляемости
# кода.
# Как и все остальное в Python, функции тоже являются объектами.
# В функцию можно передавать данные, называемые параметрами. Функция может
# возвращать данные как результат своей работы. Чтобы вызвать функцию, нужно
# указать имя функции, за которым следуют круглые скобки () с параметрами. На
# пример, функция len (х) возвращает длину параметра х.
# 6.2. Типы функций
# Функции бывают двух типов.
# ♦ Встроенные функции уже определены в Python и могут быть вызваны напря
# мую.
# ♦ Пользовательские функции - это объекты, которые создаются пользователем
# с помощью явного определения. Функция вызывается с тем же количеством ар-
# гументов, что и в формальном описании функции.
#
# 6.3. Встроенные функции
# В круглых скобках указываются объекты, который нужно передать функции в ка
# честве аргумента.
# ♦ аЬs (х) возвращает абсолютное значение числа. Аргумент может быть целым
# числом или числом с плавающей точкой. Если аргумент - комплексное число,
# возвращается его абсолютное значение.
# ♦ any (iteraЬle) возвращает тrue, если какой-либо элемент переданной
# последова
# тельности истинен. Если итерируемый объект пуст, возвращается False.
# ♦ chr (i) возвращает строку, представляющую собой символ, кодировка которого
# в таблице Unicode равна i.
# ♦ dir ([oЬject]) при вызове без аргумента возвращает список имен всех
# локальных
# объектов. С аргументом возвращает список допустимых атрибутов для передан
# ного объекта.
# ♦ float ([x]) возвращает число с плавающей точкой, полученное из числа или
# строки х.
# ♦ help ([oЬject]) - это вызов встроенной справочной системы (эта функция пред
# назначена для интерактивного использования). При вызове без аргумента на
# консоли интерпретатора запускается интерактивная справочная система. Если
# аргумент является строкой, то ищется соответствующее имя модуля, функции,
# класса, метода, ключевого слова или раздела документации, а на консоли выво
# дится страница справки. Если аргумент является объектом любого другого типа,
# для этого объекта создается справочная страница.
# ♦ id (oЬject) возвращает идентификатор объекта. Это целое число, которое
# гарантированно будет уникальным и постоянным для этого объекта в течение
# всего
# его времени жизни. Два объекта с неперекрывающимся временем жизни могут
# иметь одинаковое значение id ( ) . С точки зрения реализации CPython это
# адрес
# объекта в памяти.
# ♦ input ( [prompt] ) используется для получения ввода от пользователя. Если
# передан
# аргумент, он выводится в стандартный поток вывода без символа новой строки
# в конце.
# ♦ int ([x]) возвращает целочисленный объект, сформированный из числа или стро
# ки х.
# ♦ isinstance (oЬject, classinfo) возвращает True, если аргумент object
# является эк
# земпляром класса classinfo или его подклассом (прямым, косвенным или вирту
# альным). Если объект не является объектом данного типа, функция возвращает
# False.
# ♦ len (s) возвращает длину (количество элементов) переданного объекта. В
# качестве аргумента можно передать последовательность (например, строку,
# байтовую строку, кортеж, список или диапазон) или коллекцию (словарь,
# множество или # замороженное множество).
# ♦ шар (function, i teraЬle [ , . . . ] ) возвращает итератор, который
# применяет передан # ную функцию к каждому элементу переданного итерируемого
# объекта. Если # в функцию map ( ) передается несколько итерируемых
# аргументов, то указанная
# функция function ( ) должна принимать такое же количество аргументов и будет
# применяться к элементам из всех итерируемых аргументов параллельно. При
# этом итератор остановится, когда дойдет до конца самого короткого из итери
# руемых объектов.
# ♦ mах (argl , arg2 , *args [ , key] ) возвращает наибольший элемент в
# итерируемом
# объекте или наибольший из переданных аргументов.
# ♦ min (argl , arg2, *args [ , key] ) возвращает наименьший элемент в
# итерируемом
# объекте или наименьший из переданных аргументов.
# ♦ open (file) открывает файл и возвращает соответствующий файловый объект.
# ♦ ord(c) принимает строку, состоящую из одного символа Unicode, и возвращает
# целое число, представляющее код Unicode этого символа. Например,
# ord ( ' а ' )
# возвращает 97, а ord ( ' € ' ) возвращает вз 64. Функция обратна chr ( ) .
# ♦ print (*oЬjects , sep=' ' , end= ' \n' , file=sys . stdout, flush=False)
# выводит объекты
# в текстовый поток с разделителями sep и окончанием end. Аргументы sep, end,
# file и flush, если они есть, должны быть указаны как именованные аргументы.
# Все неименованные аргументы преобразуются в строки функцией str ( ) и запи
# сываются в поток с разделителем sep и окончанием end. И sep, и end должны
# быть
# строками. Они могут иметь значение None, в результате чего будут использовать
# ся значения по умолчанию. Без аргументов функция print ( ) просто выводит пус
# тую строку.
# ♦ repr (oЬjects) возвращает строку, содержащую формальное строковое представ
# ление объекта.
# ♦ reversed(seq) возвращает итератор в обратном порядке.
# ♦ round(m.пaЬer [ , ndigits] ) округляет число с точностью до ndigits знаков
# после де
# сятичной точки. Если аргумент ndigi ts опущен или равен None, функция возвра
# щает ближайшее целое.
# ♦ sorted (iteraЬle , * , key=None , reverse=False) возвращает новый
# отсортированный
# список из элементов переданного итерируемого.
# ♦ type (oЬject) принимает один аргумент и возвращает его тип.
#
#
# 6.4. Пользовательские функции
# Это один из самых мощных инструментов большинства языков программирования,
# который позволяет пользователю писать свои собственные функции. Это дает без
# граничные возможности для создания повторно используемого кода для выполне
# ния повторяющихся задач.
# Встроенных функций не так много. Когда программисrу нужен функционал, кото
# рого нет во встроенной библиотеке, он создает его сам.
# 6.4.1. Зачем создавать функции?
# ♦ Создавая свои функции, программист избавляется от необходимости переписы
# вать один и тот же код снова и снова. Предположим, что в вашей программе есть
# фрагмент кода, который вычисляет процентную ставку. Если вы захотите рас
# считать процентную ставку для другой основной суммы и для другого периода
# времени в той же программе, вам явно не доставит удовольствия заново писать
# один и тот же код. Вместо этого вы бы предпочли повторить выполнение фраг
# мента кода, который вычисляет проценты, а затем вернуться к тому месту, где
# вы остановились. Этот фрагмент кода - не что иное, как функция.
# ♦ Лучше разбивать разные действия на отдельные функции, чем писать всю логи
# ку в одном месте. Так у программы будет модульная структура. Более мелкие
# функции могут повторно пригодиться в аналогичных ситуациях. А если вся ло
# гика объединена в одной крупной функции, вы не сможете повторно использо
# вать какую-то ее часть, придется написать еще один фрагмент кода.
# ♦ Разделение кода на функции упрощает разработку и понимание программы.
# Также, если работа программы может быть разделена на отдельные действия и
# каждое действие помещено в отдельную функцию, вы можете писать и прове
# рять фрагменты кода независимо друг от друга.
# 6.4.2. Создание и вызов функций
# Как и у всего остального, у создания (определения) функций есть собственный
# синтаксис. Он весьма прост:
# 				def имя_функции() :
# 				тело_функции
# Когда мы пишем оператор def, интерпретатор Python понимает, что мы собираемся
# определить функцию. Совершенно очевидно, что «def» - это сокращение от англ.
# define (определять). Теперь мы должны дать нашей функции уникальное имя. По
# сле слова def следует имя функции, затем пара круглых скобок() и двоеточие
# (:).
# В следующей строке идет тело функции. Оно начинается с отступа, который сооб
# щает Python, что этот блок кода является телом функции. Тело функции - это не
# что иное, как код, который функция выполняет.
# Имя, которое мы даем нашей функции, должно быть уникальным, как и перемен-
# ные. Мы можем назвать нашу функцию как угодно, но необходимо при этом
# соблюдать правила языка Python. Кроме того, функцию следует наделять таким
# именем, которое связано с ее назначением, т. е. имеет смысл.


def lemonade_stall(price: int) -> None:
    """Print lemonade content."""
    if price == 50:
        print("Лимонад сделан из :")
        print("Лимонный сок")
        print("Boдa")
        print("Coль")
        print("Caxap")
    elif price == 100:
        print("Sprite сделан из :")
        print("Лимонный сок")
        print("Coдoвaя")
        print("Caxap")
        print("Секретный ингредиент")
    else:
        print("Пожалуйста, заплатите нужную сумму")


lemonade_stall(80)


# 6.4.2.1. Количество аргументов
# Когда вы вызываете функцию, ей нужно передать правильное количество аргумен-
# тов. То есть если у функции определены 2 параметра, вы должны передать ей
# 2 аргумента, не больше и не меньше.


def my_name(first_name: str, last_name: str) -> None:
    """Print my_name."""
    print(first_name, last_name)


my_name("Nilabh", "Nishchhal")


def fib(number: int) -> list[int]:
    """Generate Fibonacci numbers up to the given number."""
    if number <= 0:
        return []  # Если число не положительное, возвращаем пустой список

    result = []
    alfa, beta = 0, 1

    while alfa < number:
        result.append(alfa)
        alfa, beta = beta, alfa + beta

    return result  # Возвращаем список чисел Фибоначчи


limit = 100
fibonacci_numbers = fib(limit)
print(f"Fibonacci numbers up to {limit}: {fibonacci_numbers}")


def fib2(number: int) -> list[int]:
    """Generate Fibonacci numbers up to the given number."""
    result = []
    alfa, beta = 0, 1
    while alfa < number:
        result.append(alfa)
        alfa, beta = beta, alfa + beta
    return result


# Получаем список чисел Фибоначчи до 100
print(fib2(100))


# Оператор return возвращает значение из функции. Если после оператора return
# ничего не указать, возвращается None. Если этот оператор отсутствует в конце
# функции, тоже возвращается None.
#
# 6.5. Варианты передачи аргументов
# Существуют четыре варианта передачи аргументов, которые можно комбинировать.
# 1. Аргументы со значением по умолчанию.
# 2. Произвольное число аргументов (*args).
# 3. Именованные аргументы.
# 4. Произвольное число именованных аргументов (**kwargs)
#
# Наиболее полезный вариант - это указать для одного или нескольких аргументов
# значение по умолчанию. В этом случае функцию можно вызвать с меньшим коли-
# чеством аргументов, чем в ней определено.


def my_address(city: str, state: str, country: str = "India") -> None:
    """Print address."""
    print("I live in", city, ",", state, ",", country)


my_address("Mumbai", "Maharashtra")

my_address(" Sydney", "New South Wales", "Australia")


# Значение по умолчанию не означает, что это единственное значение, которое мо-
# жет принимать данный параметр. Вы можете передать в функцию любое другое
# значение. То есть если при вызове функции вы не указываете для этого
# аргумента
# значение, он принимает значение по умолчанию.

# Если вы не знаете, сколько аргументов будет передано в вашу функцию, добавьте
# перед именем параметра в определении функции символ *.
# Таким образом, функция получит кортеж аргументов и сможет соответственно
# обращаться к элементам кортежа.


def fruit_basket(*fruit: str) -> None:
    """Print fruts."""
    print(fruit)


fruit_basket("apple", "grapes", "strawberry")


def parrot(
    volt: str,
    state: str = "мертв",
    action: str = "оживет",
    tip: str = "Норвежский голубой",
) -> None:
    """Parrot constructor."""
    print("- Этот попугай не", action, end=" ")
    print("дaжe если пропустить", volt, "вольт через него .")
    print("- Какое оперение! ", tip)
    print("- Он", state, "!")


parrot("тысяча")  # первый позиционный аргумент
parrot(volt="тысяча")  # первый именованный аргумент
parrot(volt="миллион", action="полетит")  # два именованных аргумента
parrot(action="полетит", volt="миллион")  # два именованных аргумента
parrot("миллион", "отправился к праотцам", "прыгнет")
parrot("тысячу", state="летает c ангелами")


# Если количество именованных аргументов, передаваемых в функцию, неиз-
# вестно, можно добавить перед именем параметра в определении функции две
# звездочки **.
# В этом случае функция получит словарь аргументов, из которого сможет
# получить доступ к его элементам по именам.


def try_function(*args: str, **kwargs: str) -> None:
    """Print week days."""
    print("args:", args)
    print("kwargs:", kwargs)


try_function(
    "Monday",
    "Tuesday",
    "Wednesday",
    fourth_="Thursday",
    fifth_="Friday",
    weekendl_="Saturday",
    weekend2_="Sunday",
)


# 6.6. Генераторы
# Генератор - это функция, возвращающая итератор. То есть эти функции генери-
# руют объект, который можно перебирать в цикле.
# Генератор - это особый класс функций. Вместо того, чтобы возвращать одно зна-
# чение, функция-генератор возвращает последовательность значений (объект -
# итератор). Слово return в таких функциях заменяется на yield. Если функция
# содержит хотя бы один оператор yield (а при этом она может содержать
# несколько
# yield или return), она становится функцией-генератором. Разница между return
# и yield заключается в том, что оператор return полностью завершает функцию,
# а оператор yield приостанавливает выполнение функции и сохраняет все ее
# локальные переменные, а затем продолжает выполнение с того же места при
# последующем вызове или итерации.


def inclusive_range(*args: int):  # type: ignore
    """Generate function."""
    numargs = len(args)
    start = 0
    step = 1

    if numargs < 1:
        raise TypeError(f"Expected at least one argument, got {numargs}")
    if numargs == 1:
        stop = args[0]
    elif numargs == 2:
        (start, stop) = args
    elif numargs == 3:
        (start, stop, step) = args
    else:
        raise TypeError("Expected at most 3 arguments, got {numargs}")

    begin = start
    while begin <= stop:
        yield begin
        begin += step


inclusive_range()

for item in inclusive_range(25):
    print(item, end=" ")


# 6.7. Резюме
# 1. Изучила встроенные функции и рассмотрела самые полезные из них.
# 2. Узнала как определять и вызывать собственные функции.
# 3. Изучила параметры и аргументы функции.
# 4. Узнала, как можно более эффективно использовать разные аргументы
# для вызова функции.

# 6.8.1. Ответьте на вопросы
# 1. В чем различие между функцией и методом?
# Ответ:
# Методы связаны с объектами и могут изменять их состояние, в то время
# как функции независимы от объектов.
# 2. Как создание своих функций помогает программисту в работе?
# Ответ:
# Дает безграничные возможности для создания повторно используемого
# кода для выполнения повторяющихся задач.
# 3. Чем ограничено тело функции?
# Ответ:
# Тело функции - это блок кода, им же оно
# и ограничено.
# 4. Можно ли использовать функцию, находящуюся внутри модуля, за пределами
# модуля?
# Ответ:
# Можно, если ее передать за пределы модуля
# 5. В чем сходство и различие параметров и аргументов функции?
# Ответ:
# Параметры — это переменные, которые определяются в заголовке функции и
# используются внутри неё. Аргументы — это значения, которые передаются в
# функцию при её вызове.
# 6. Зачем в определении функции нужен оператор return? Что вернет функция,
# если
# в ее определении нет оператора return?
# Ответ:
# Если функция должна обработать какие-то данные и потом вернуть их, то
# для возвращения этих данных необходим этот оператор. Если в функции
# отсутствует оператор return или он используется без значения, функция вернёт
# None.
# 7. Как обозначается произвольное количество аргументов? Когда они использу-
# ются?
# Ответ:
# Проивольное количество аргументов обозначается *args.  Внутри функции
# *args будет представлен в виде кортежа, содержащего все переданные аргументы.
# 8. Что такое функция-генератор? Чем она отличается от обычных функций?
# Ответ:
# Генератор — это объект, который сразу при создании не вычисляет значения всех
# своих элементов. Он хранит в памяти только последний вычисленный элемент,
# правило перехода к следующему и условие, при котором выполнение прерывается.
# Функция-генератор отличается от обычной функции тем, что вместо команды
# return в ней используется yield
# 9. В чем разница между args и kwargs? Что это такое?
# Ответ:
# **kwargs - это те же элементы, но именнованные
# *args позволяет передавать в функцию произвольное количество позиционных
# аргументов. **kwargs позволяет передавать произвольное количество именованных
# аргументов (аргументов с ключами).

# 6.8.2. Правда или ложь
# 1. Чтобы вернуть значение из функции, нужно использовать оператор return.
# ПРАВДА
# 2. Каждый оператор return в функции может возвращать свое значение.
# ПРАВДА
# 3. Функция обязательно должна возвращать какое-то значение.
# ЛОЖЬ
# 4. Функция, которая не возвращает никакого значения, возвращает None.
# ПРАВДА
# 5. При определении функции нужно указать хотя бы один параметр.
# ЛОЖЬ
# 6. Имя *args - это всего лишь соглашение. Вместо args можно использовать
# любое другое имя.
# ПРАВДА
# 7. Функция, которая выводит значения на экран, аналогична функции, возвра-
# щающей эти значения.
# ЛОЖЬ
# 8. Различные виды аргументов в одной функции определять нельзя.
# ЛОЖЬ
# 9. При использовании именованных аргументов их порядок не имеет значения.
# ПРАВДА
# 10. В функции-генераторе нужно использовать оператор yield вместо оператора
# return.
# ПРАВДА

# 6.8.3. Практические задания

# 1. Напишите функцию, которая проверяет, является ли год високосным.


def which_years(year: int) -> str:
    """Show leap year."""
    if year % 4 == 0:
        return f"{year} - високосный год"
    return f"{year} - не високосный год"


# Пример использования
year_input = int(input("Введите год: "))
print(which_years(year_input))  # Выводим результат функции

# 2. Напишите функцию f(х), возвращающую простые множители любого числа х
# (пример простых множителей: 36 - [2 2 3 3], 30 - [2 3 5] ).

# +
ex = int(input("1:>"))


def funk(number: int) -> list[int]:
    """Prime factors."""
    i_num, res = 2, []
    while i_num * i_num <= number:
        if number % i_num == 0:
            res.append(i_num)
            number //= i_num
        else:
            i_num += 1
    if number > 1:
        res.append(number)
    return res


print(funk(ex))

# 3.Напишите функцию для преобразования температуры из градусов Цельсия
# в градусы Фаренгейта. Напишите еще одну функцию для обратного
# преобразования.

# +
temperature = int(input("1:>"))


def converter_c_to_f(celsius: int) -> int:
    """Convert from celsius to foringate."""
    foringate = round((celsius * 9 / 5) + 32)
    return foringate


# -

print(converter_c_to_f(temperature))

# +
temperature = int(input("2:>"))


def converter_f_to_c(foringate: int) -> int:
    """Convert from celsius to foringate."""
    celsius = round((foringate - 32) * 5 / 9)
    return celsius


# -

print(converter_f_to_c(temperature))

# 4. Напишите функцию для вычисления факториала любого числа.

# +
num_input = int(input("3:>"))


def factorial(number: int) -> int:
    """Find factorial."""
    return 1 if number in (1, 0) else number * factorial(number - 1)


print(factorial(num_input))
# -

# 5. Напишите функцию преобразования любого числа от 1 до 100 в римское число.


def integer_to_roman(arab_num: int) -> str:
    """Convert integer to roman numeral."""
    # Римские числа с учетом всех возможных значений
    romansdict = {
        1: "I",
        4: "IV",
        5: "V",
        9: "IX",
        10: "X",
        40: "XL",
        50: "L",
        90: "XC",
        100: "C",
        400: "CD",
        500: "D",
        900: "CM",
        1000: "M",
    }

    res = ""

    # Для каждого числа начиная с самого большого
    for value in sorted(romansdict.keys(), reverse=True):
        while arab_num >= value:
            res += romansdict[value]
            arab_num -= value

    return res


print(integer_to_roman(12))

# 6. Напишите функцию f(х), которая возвращает таблицу умножения числа х.

# +
number1 = int(input("4:>"))


def multiplication_table(multi_num: int) -> None:
    """Make multiplication table."""
    for i_num in range(1, 11):
        res = multi_num * item
        print(f"{multi_num} * {i_num} = {res}")


multiplication_table(number1)


# -

# 7. Напишите функцию, которая принимает в качестве входных данных список и
# возвращает его перевернутый вариант.


# +
def reverse_list(lst: str) -> None:
    """Revers list."""
    rev_list = lst[::-1]
    print(rev_list)


my_list = input("6:>")
reverse_list(my_list)
# -

# 8. Напишите функцию для расчета сложных процентов.

# +
summa = int(input("Сумма"))
number2 = int(input("Ставка"))
period = int(input("Лет"))


def calculate_profit(money: int, rate: int, years: int) -> None:
    """Calculate compound Interest."""
    for _ in range(years):
        percent = money * (1 + rate)
        print(percent)


calculate_profit(summa, number2, period)


# -

# 9. Напишите функцию f(х) , где х - любое 6-значное число, а функция
# возвращает сумму его цифр.


# +
def make_summ(number: str) -> None:
    """Calculate sum."""
    summ = 0
    for i_num in number:
        summ += int(i_num)
    print(summ)


frase = "456789"
make_summ(frase)
# -

# 10. Напишите функцию, которая проверяет, является ли переданное число
# простым.
#

# +
number3 = int(input("5:>"))


def prime_number(num: int) -> None:
    """Determine prime number."""
    if num > 1:
        for i_num in range(2, (num // 2) + 1):
            if (num % i_num) == 0:
                print(False)
                break
            print(True)


prime_number(number3)
